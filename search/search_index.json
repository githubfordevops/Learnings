{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learnings This site contains my technical learnings, notes, and explanations collected over time. The content is organized by topic and is intended to be both a personal reference and a shareable knowledge base. Linux Notes related to Linux internals, commands, and system behavior. SSH known_hosts Understanding how SSH verifies server identity and prevents man-in-the-middle attacks. Golang Learnings from working with Go, especially in the context of Kubernetes operators. Reconciler basics Detailed explanation of how the Kubernetes reconciler works, how requests are routed, and why reconciliation is idempotent. Sync Waitgroup Explantion of How Sync_waitgroup works with sample code snippets. Others Miscellaneous notes that don\u2019t fit into a single core category. Helpfile General helper notes and references. Git commands Commonly used Git commands and workflows for day-to-day development. How to use this site Use the left navigation menu to browse by topic Each page focuses on one specific learning Pages are written in Markdown and rendered using MkDocs Notes URLs do not end with .md Each page is mapped to a folder-style URL Content is continuously evolving as new learnings are added","title":"Home"},{"location":"#learnings","text":"This site contains my technical learnings, notes, and explanations collected over time. The content is organized by topic and is intended to be both a personal reference and a shareable knowledge base.","title":"Learnings"},{"location":"#linux","text":"Notes related to Linux internals, commands, and system behavior. SSH known_hosts Understanding how SSH verifies server identity and prevents man-in-the-middle attacks.","title":"Linux"},{"location":"#golang","text":"Learnings from working with Go, especially in the context of Kubernetes operators. Reconciler basics Detailed explanation of how the Kubernetes reconciler works, how requests are routed, and why reconciliation is idempotent. Sync Waitgroup Explantion of How Sync_waitgroup works with sample code snippets.","title":"Golang"},{"location":"#others","text":"Miscellaneous notes that don\u2019t fit into a single core category. Helpfile General helper notes and references. Git commands Commonly used Git commands and workflows for day-to-day development.","title":"Others"},{"location":"#how-to-use-this-site","text":"Use the left navigation menu to browse by topic Each page focuses on one specific learning Pages are written in Markdown and rendered using MkDocs","title":"How to use this site"},{"location":"#notes","text":"URLs do not end with .md Each page is mapped to a folder-style URL Content is continuously evolving as new learnings are added","title":"Notes"},{"location":"golang/reconciler-basics/","text":"Understanding the Reconciler in a Kubernetes Operator (Go) Overview In a Kubernetes operator built using Kubebuilder, the Reconciler is the core component responsible for driving the actual state of the cluster towards the desired state defined by a Custom Resource (CR). Each reconciliation cycle operates on one specific resource instance . Reconciler function signature ```go func (r *MyReconciler) Reconcile( ctx context.Context, req ctrl.Request, ) (ctrl.Result, error)","title":"Reconciler basics"},{"location":"golang/reconciler-basics/#understanding-the-reconciler-in-a-kubernetes-operator-go","text":"","title":"Understanding the Reconciler in a Kubernetes Operator (Go)"},{"location":"golang/reconciler-basics/#overview","text":"In a Kubernetes operator built using Kubebuilder, the Reconciler is the core component responsible for driving the actual state of the cluster towards the desired state defined by a Custom Resource (CR). Each reconciliation cycle operates on one specific resource instance .","title":"Overview"},{"location":"golang/reconciler-basics/#reconciler-function-signature","text":"```go func (r *MyReconciler) Reconcile( ctx context.Context, req ctrl.Request, ) (ctrl.Result, error)","title":"Reconciler function signature"},{"location":"golang/sync_waitgroup/","text":"sync.WaitGroup in Go sync.WaitGroup is a synchronization primitive in Go used to wait for a collection of goroutines to finish executing . It is commonly used when: - launching multiple goroutines - you need to block until all of them complete - you do NOT need to return values directly (channels are used for that) Why WaitGroup is needed Goroutines run asynchronously. Without synchronization, the main function may exit before goroutines finish. go doWork() fmt.Println(\"main done\") // may execute before doWork finishes Basic Usage Pattern var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() // work here }() wg.Wait() Single GoRoutine package main import ( \"fmt\" \"sync\" ) func main() { var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() fmt.Println(\"Hello from goroutine\") }() wg.Wait() fmt.Println(\"All goroutines finished\") } Multiple Goroutines var wg sync.WaitGroup for i := 0; i < 5; i++ { wg.Add(1) go func(i int) { defer wg.Done() fmt.Println(\"Worker\", i) }(i) } wg.Wait() fmt.Println(\"All workers done\") Waiting for Http Calls var wg sync.WaitGroup urls := []string{ \"https://example.com\", \"https://golang.org\", } for _, url := range urls { wg.Add(1) go func(u string) { defer wg.Done() fmt.Println(\"Fetching\", u) }(url) } wg.Wait() WaitGroup with channels var wg sync.WaitGroup results := make(chan int, 5) for i := 0; i < 5; i++ { wg.Add(1) go func(i int) { defer wg.Done() results <- i * 2 }(i) } go func() { wg.Wait() close(results) }() for r := range results { fmt.Println(\"Result:\", r) } Other details Do not call Add() inside goroutines go func() { wg.Add(1) // WRONG }() Use defer wg.Done() Ensures Done() is called even if the function returns early. Other Links [Go Official Docs] (https://pkg.go.dev/sync#WaitGroup)","title":"Sync_waitgroup"},{"location":"golang/sync_waitgroup/#syncwaitgroup-in-go","text":"sync.WaitGroup is a synchronization primitive in Go used to wait for a collection of goroutines to finish executing . It is commonly used when: - launching multiple goroutines - you need to block until all of them complete - you do NOT need to return values directly (channels are used for that)","title":"sync.WaitGroup in Go"},{"location":"golang/sync_waitgroup/#why-waitgroup-is-needed","text":"Goroutines run asynchronously. Without synchronization, the main function may exit before goroutines finish. go doWork() fmt.Println(\"main done\") // may execute before doWork finishes","title":"Why WaitGroup is needed"},{"location":"golang/sync_waitgroup/#basic-usage-pattern","text":"var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() // work here }() wg.Wait()","title":"Basic Usage Pattern"},{"location":"golang/sync_waitgroup/#single-goroutine","text":"package main import ( \"fmt\" \"sync\" ) func main() { var wg sync.WaitGroup wg.Add(1) go func() { defer wg.Done() fmt.Println(\"Hello from goroutine\") }() wg.Wait() fmt.Println(\"All goroutines finished\") }","title":"Single GoRoutine"},{"location":"golang/sync_waitgroup/#multiple-goroutines","text":"var wg sync.WaitGroup for i := 0; i < 5; i++ { wg.Add(1) go func(i int) { defer wg.Done() fmt.Println(\"Worker\", i) }(i) } wg.Wait() fmt.Println(\"All workers done\")","title":"Multiple Goroutines"},{"location":"golang/sync_waitgroup/#waiting-for-http-calls","text":"var wg sync.WaitGroup urls := []string{ \"https://example.com\", \"https://golang.org\", } for _, url := range urls { wg.Add(1) go func(u string) { defer wg.Done() fmt.Println(\"Fetching\", u) }(url) } wg.Wait()","title":"Waiting for Http Calls"},{"location":"golang/sync_waitgroup/#waitgroup-with-channels","text":"var wg sync.WaitGroup results := make(chan int, 5) for i := 0; i < 5; i++ { wg.Add(1) go func(i int) { defer wg.Done() results <- i * 2 }(i) } go func() { wg.Wait() close(results) }() for r := range results { fmt.Println(\"Result:\", r) }","title":"WaitGroup with channels"},{"location":"golang/sync_waitgroup/#other-details","text":"","title":"Other details"},{"location":"golang/sync_waitgroup/#do-not-call-add-inside-goroutines","text":"go func() { wg.Add(1) // WRONG }()","title":"Do not call Add() inside goroutines"},{"location":"golang/sync_waitgroup/#use-defer-wgdone","text":"Ensures Done() is called even if the function returns early.","title":"Use defer wg.Done()"},{"location":"golang/sync_waitgroup/#other-links","text":"[Go Official Docs] (https://pkg.go.dev/sync#WaitGroup)","title":"Other Links"},{"location":"k8s/NSR/","text":"NSR in Kubernetes Contexts This document explains two possible interpretations of NSR in Kubernetes-related architectures: 1. NSR in Network Service Mesh 2. Container Registry usage in Kubernetes (if NSR was a misinterpretation) NSR within a Kubernetes Network Service Mesh In the Network Service Mesh (NSM) architecture, the NSR (also referred to as MSR \u2013 Mesh Service Registry ) acts as the central service discovery mechanism . Service Discovery The Kubernetes API server\u2019s etcd is commonly leveraged as the backing store for the registry. It stores information about: Available network services Network Service Endpoints (NSEs) Associated metadata Registration Process NSMgr (Network Service Manager) runs as a control-plane component on each node. Its responsibilities include: Discovering local Network Service Endpoints (NSEs) Registering these NSEs with the NSR via the Kubernetes API server This ensures that all available services and endpoints are visible at the mesh level. Service Consumption A Network Service Client (NSC) , typically a Pod with specific annotations, requests a network service. The workflow is as follows: The local NSMgr receives the service request It queries the NSR (via the API server) for a suitable NSE A virtual wire (connection) is established between: The requesting client The selected Network Service Endpoint This enables dynamic, policy-driven service connectivity across the mesh. General Container Registry Usage in Kubernetes If \u201cNSR\u201d is a typo or misinterpretation and instead refers to the general concept of a container image registry in Kubernetes, the process is different and focuses on image distribution and authentication . Image Pulling The kubelet component on each node is responsible for pulling container images. It uses the configured container runtime, such as: Docker containerd CRI-O Images are pulled from a specified container registry. Authentication (Image Pull Secrets) For private container registries (for example: Docker Hub, AWS ECR, Azure Container Registry, Google Artifact Registry): A Kubernetes Secret of type kubernetes.io/dockerconfigjson must be created. This secret stores: Registry endpoint Authentication credentials Linking Secrets to Pods The image pull secret is referenced in the Pod specification. This allows the kubelet to authenticate with the registry and pull the required image. Example usage scenarios include: - Private enterprise registries - Cloud-provider-managed registries - Secured internal image repositories Summary In Network Service Mesh , NSR refers to a service registry used for discovering and connecting network services. In standard Kubernetes usage, registries are used for container image storage and distribution . These two concepts are unrelated but can be confused due to similar terminology. Understanding the context in which NSR is used is critical to interpreting its role correctly.","title":"NSR"},{"location":"k8s/NSR/#nsr-in-kubernetes-contexts","text":"This document explains two possible interpretations of NSR in Kubernetes-related architectures: 1. NSR in Network Service Mesh 2. Container Registry usage in Kubernetes (if NSR was a misinterpretation)","title":"NSR in Kubernetes Contexts"},{"location":"k8s/NSR/#nsr-within-a-kubernetes-network-service-mesh","text":"In the Network Service Mesh (NSM) architecture, the NSR (also referred to as MSR \u2013 Mesh Service Registry ) acts as the central service discovery mechanism .","title":"NSR within a Kubernetes Network Service Mesh"},{"location":"k8s/NSR/#service-discovery","text":"The Kubernetes API server\u2019s etcd is commonly leveraged as the backing store for the registry. It stores information about: Available network services Network Service Endpoints (NSEs) Associated metadata","title":"Service Discovery"},{"location":"k8s/NSR/#registration-process","text":"NSMgr (Network Service Manager) runs as a control-plane component on each node. Its responsibilities include: Discovering local Network Service Endpoints (NSEs) Registering these NSEs with the NSR via the Kubernetes API server This ensures that all available services and endpoints are visible at the mesh level.","title":"Registration Process"},{"location":"k8s/NSR/#service-consumption","text":"A Network Service Client (NSC) , typically a Pod with specific annotations, requests a network service. The workflow is as follows: The local NSMgr receives the service request It queries the NSR (via the API server) for a suitable NSE A virtual wire (connection) is established between: The requesting client The selected Network Service Endpoint This enables dynamic, policy-driven service connectivity across the mesh.","title":"Service Consumption"},{"location":"k8s/NSR/#general-container-registry-usage-in-kubernetes","text":"If \u201cNSR\u201d is a typo or misinterpretation and instead refers to the general concept of a container image registry in Kubernetes, the process is different and focuses on image distribution and authentication .","title":"General Container Registry Usage in Kubernetes"},{"location":"k8s/NSR/#image-pulling","text":"The kubelet component on each node is responsible for pulling container images. It uses the configured container runtime, such as: Docker containerd CRI-O Images are pulled from a specified container registry.","title":"Image Pulling"},{"location":"k8s/NSR/#authentication-image-pull-secrets","text":"For private container registries (for example: Docker Hub, AWS ECR, Azure Container Registry, Google Artifact Registry): A Kubernetes Secret of type kubernetes.io/dockerconfigjson must be created. This secret stores: Registry endpoint Authentication credentials","title":"Authentication (Image Pull Secrets)"},{"location":"k8s/NSR/#linking-secrets-to-pods","text":"The image pull secret is referenced in the Pod specification. This allows the kubelet to authenticate with the registry and pull the required image. Example usage scenarios include: - Private enterprise registries - Cloud-provider-managed registries - Secured internal image repositories","title":"Linking Secrets to Pods"},{"location":"k8s/NSR/#summary","text":"In Network Service Mesh , NSR refers to a service registry used for discovering and connecting network services. In standard Kubernetes usage, registries are used for container image storage and distribution . These two concepts are unrelated but can be confused due to similar terminology. Understanding the context in which NSR is used is critical to interpreting its role correctly.","title":"Summary"},{"location":"linux/known_hosts/","text":"Engineering Learnings This repository contains curated technical learnings collected over time. Topics include: - Linux - Python - Kubernetes - Go - YAML / Configurations \ud83d\udcd8 Browse online (MkDocs) or directly via Markdown files. How to view locally ```bash pip install mkdocs mkdocs-material mkdocs serve","title":"SSH known_hosts"},{"location":"linux/known_hosts/#engineering-learnings","text":"This repository contains curated technical learnings collected over time. Topics include: - Linux - Python - Kubernetes - Go - YAML / Configurations \ud83d\udcd8 Browse online (MkDocs) or directly via Markdown files.","title":"Engineering Learnings"},{"location":"linux/known_hosts/#how-to-view-locally","text":"```bash pip install mkdocs mkdocs-material mkdocs serve","title":"How to view locally"},{"location":"others/Helpfile/","text":"You\u2019ve written your first proper technical note \ud83c\udf89 10\ufe0f\u20e3 How to VIEW Markdown Option A \u2014 VS Code (recommended) Install VS Code Open .md file Press Ctrl + Shift + V Option B \u2014 GitHub Push file to GitHub GitHub renders Markdown automatically Markdown cheat sheet (save this) What Syntax Heading # ## ### After #, a space has to be present Bullet list - item Bold **text** Code `code` Code block 3 s optionally followed by lang(ex:go) and then 3 s to close the code block Link [text](url) What you should do now (practice) Create one Markdown file Write any one learning you already know Use: 1 heading 1 bullet list 1 code block Next step (after this) Next I\u2019ll explain Git with: - Only 5 commands - No theory - Exact commands you\u2019ll type \ud83d\udc49 When ready, reply: \u201cNext: Git\u201d","title":"Helpfile"},{"location":"others/Helpfile/#10-how-to-view-markdown","text":"","title":"10\ufe0f\u20e3 How to VIEW Markdown"},{"location":"others/Helpfile/#option-a-vs-code-recommended","text":"Install VS Code Open .md file Press Ctrl + Shift + V","title":"Option A \u2014 VS Code (recommended)"},{"location":"others/Helpfile/#option-b-github","text":"Push file to GitHub GitHub renders Markdown automatically","title":"Option B \u2014 GitHub"},{"location":"others/Helpfile/#markdown-cheat-sheet-save-this","text":"What Syntax Heading # ## ### After #, a space has to be present Bullet list - item Bold **text** Code `code` Code block 3 s optionally followed by lang(ex:go) and then 3 s to close the code block Link [text](url)","title":"Markdown cheat sheet (save this)"},{"location":"others/Helpfile/#what-you-should-do-now-practice","text":"Create one Markdown file Write any one learning you already know Use: 1 heading 1 bullet list 1 code block","title":"What you should do now (practice)"},{"location":"others/Helpfile/#next-step-after-this","text":"Next I\u2019ll explain Git with: - Only 5 commands - No theory - Exact commands you\u2019ll type \ud83d\udc49 When ready, reply: \u201cNext: Git\u201d","title":"Next step (after this)"},{"location":"others/gitfilecommands/","text":"git status # see changes git add . # select them git commit -m \"Added learning about X\" git push # share","title":"Git Commands"}]}